{"version":3,"file":"unimodules.js","sourceRoot":"","sources":["../../../src/builders/utils/unimodules.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport filter from 'lodash/filter';\nimport keys from 'lodash/keys';\nimport merge from 'lodash/merge';\nimport values from 'lodash/values';\nimport path from 'path';\nimport logger from 'turtle/logger';\n\nexport interface IUnimoduleEntry {\n  name: string;\n  version: string;\n  dirname: string;\n}\n\ninterface IPackageInfo {\n  name: string;\n  version: string;\n  dirname: string; // could be different than name\n  dependencies: string[];\n}\n\nexport async function resolveExplicitOptIn(workingdir: string, packages?: string[]): Promise<IUnimoduleEntry[]> {\n  const resolver = new Resolver(workingdir);\n  await resolver.init();\n\n  const optionalModules = ['expo-branch'];\n  resolver.addAll();\n  const modules = packages\n    ? resolver.getModules().filter((mod) => !optionalModules.includes(mod.name) || packages.includes(mod.name))\n    : resolver.getModules().filter((mod) => !optionalModules.includes(mod.name));\n\n  modules.forEach(({ name, version }) => { logger.info(`Adding ${name}:${version}`); });\n  return modules;\n}\n\nexport async function resolveNativeModules(workingdir: string, packages?: string[]): Promise<IUnimoduleEntry[]> {\n  const resolver = new Resolver(workingdir);\n  await resolver.init();\n\n  if (!packages) {\n    resolver.addAll();\n  } else {\n    const corePackages = await readCorePackages(workingdir);\n    for (const pkg of corePackages) {\n      if (resolver.isUnimodule(pkg)) {\n        resolver.addModule(pkg);\n      }\n    }\n    for (const pkg of packages) {\n      if (resolver.isUnimodule(pkg)) {\n        resolver.addModule(pkg);\n      }\n    }\n  }\n  const modules = resolver.getModules();\n  modules.forEach(({ name, version }) => { logger.info(`Adding ${name}:${version}`); });\n  return modules;\n}\n\nasync function readCorePackages(workingdir: string) {\n  const pkgJsonPath = path.join(workingdir, 'node_modules', 'react-native-unimodules', 'package.json');\n  const expoPkgJsonPath = path.join(workingdir, 'packages', 'expo', 'package.json');\n  if (await fs.pathExists(pkgJsonPath) && await fs.pathExists(expoPkgJsonPath)) {\n    const packageJson = JSON.parse(await fs.readFile(pkgJsonPath, 'utf-8'));\n    const expoPackageJson = JSON.parse(await fs.readFile(expoPkgJsonPath, 'utf-8'));\n    return keys(packageJson.dependencies).concat(keys(expoPackageJson.dependencies));\n  } else {\n    logger.warn('No core packages detected');\n    return [];\n  }\n}\n\ninterface IDependencyInfo {\n  [key: string]: IPackageInfo;\n}\n\nclass Resolver {\n  private workingdir: string;\n  private modulesMap: {[key: string]: IUnimoduleEntry};\n  private dependencyMap: IDependencyInfo;\n\n  constructor(workingdir: string) {\n    this.workingdir = workingdir;\n    this.modulesMap = {};\n    this.dependencyMap = {};\n  }\n\n  public async init() {\n    this.dependencyMap = await generateDependenciesInfo(this.workingdir);\n  }\n\n  public isUnimodule(moduleName: string): boolean {\n    return !!this.dependencyMap[moduleName];\n  }\n\n  public addAll() {\n    for (const moduleName of Object.keys(this.dependencyMap)) {\n      this.addModule(moduleName);\n    }\n  }\n\n  public addModule(moduleName: string) {\n    if (this.dependencyMap[moduleName]) {\n      this.resolveModule(moduleName);\n    } else {\n      throw new Error('Attempting to add unknown module');\n    }\n  }\n\n  public getModules(): IUnimoduleEntry[] {\n     return values(this.modulesMap);\n  }\n\n  private async resolveModule(moduleName: string) {\n    if (this.modulesMap[moduleName]) {\n      return;\n    }\n    const pkg = this.dependencyMap[moduleName];\n    this.modulesMap[moduleName] = {\n      name: pkg.name,\n      dirname: pkg.dirname,\n      version: pkg.version,\n    };\n    for (const dep of pkg.dependencies) {\n      this.resolveModule(dep);\n    }\n  }\n}\n\nasync function generateDependenciesInfo(workingdir: string): Promise<IDependencyInfo> {\n  const dir = await fs.readdir(path.join(workingdir, 'packages'));\n  const map: IDependencyInfo = {};\n\n  // scrap directory for package metadata\n  for (const pkgName of dir) {\n    const pkg = await getPackage(workingdir, pkgName);\n    if (pkg) {\n      map[pkg.name] = pkg;\n    }\n  }\n\n  // handle @unimodules directory\n  const unimodulesDir = await fs.readdir(path.join(workingdir, 'packages', '@unimodules'));\n  for (const pkgName of unimodulesDir) {\n    const pkg = await getPackage(workingdir, path.join('@unimodules', pkgName));\n    if (pkg) {\n      map[pkg.name] = pkg;\n    }\n  }\n\n  // remove non unimodule dependencies\n  for (const pkg of Object.keys(map)) {\n    map[pkg].dependencies = filter(map[pkg].dependencies, (dep) => !!map[dep]);\n  }\n  return map;\n}\n\nasync function getPackage(workingdir: string, pkgName: string): Promise<IPackageInfo | null> {\n  const pkgPath = path.join(workingdir, 'packages', pkgName);\n  const isAndroid = await fs.pathExists(path.join(pkgPath, 'android'));\n  const isIos = await fs.pathExists(path.join(pkgPath, 'ios'));\n  const isUnimodule = await fs.pathExists(path.join(pkgPath, 'unimodule.json'));\n  const hasPackageJson = await fs.pathExists(path.join(pkgPath, 'package.json'));\n  if (!isUnimodule || !hasPackageJson || (!isAndroid && !isIos)) {\n    return null;\n  }\n\n  const packageJson = JSON.parse(await fs.readFile(path.join(pkgPath, 'package.json'), 'utf-8'));\n\n  const pkgDeps = merge({}, // reading everything to make sure\n    packageJson.dependencies,\n    packageJson.peerDependencies,\n    packageJson.unimodulePeerDependencies,\n  );\n  const info: IPackageInfo = {\n    name: packageJson.name,\n    version: packageJson.version,\n    dirname: pkgName,\n    dependencies: Object.keys(pkgDeps),\n  };\n\n  return info;\n}\n"]}